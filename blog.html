<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="css/style.css">

    <!-- 1. Update this -->
    <title>LCC Blogs - Quick Sort for Dummies</title>
</head>
<body class="blog-article-page">
    <nav class="navbar navbar-dark sticky-top">
        <div class="container">
            <a href="https://lccjssstu.org/" class="navbar-brand">
                <img src="images/lcc_icon.png" alt="LCC Logo" />
                <span>Linux Campus Club</span>
            </a>
        </div>
    </nav>

    <main class="card container">
        <div class="card-header d-flex justify-content-between">
            <a href="index.html"><i class="fa fa-chevron-left"></i> Back</a>

            <!-- 2. Update this -->
            <a href="https://www.instagram.com/sari_kanappa/" target="_blank"><i class="fa fa-instagram"></i> Akash Raj</a>
        </div>

        <!-- 3. Update these -->
        <div class="card-body">
            <h1 class="card-title">Quick Sort for Dummies</h1>
            <p>
                Mahatma Gandhi once said "Good algorithms are better than supercomputers". Just kidding; he didn't. Still, it's fascinating to see how big of an impact a good algorithm can make in today's world where everything is computationally intensive, millions of TBs of data pouring in every hour of every day. A good algorithm is always the need of the hour.
            </p>
            <p>
                I present to you one of the game changers in the world of computer algorithms. The quicksort algorithm, which is honored as one of the top 10 algorithms of the 20th century. Sir Charles Antony Richard Hoare won the Turing Award in 1980 for this exceptionally great algorithm's discovery.
            </p>
            <p>
                Algorithms are a way to tell the computer how to execute a particular task step by step. A sorting algorithm is an algorithm that puts elements of a list in a certain order; be it ascending or descending. There are several sorting algorithms ranging from a basic comparing and swapping adjacent items to the algorithms that took decades to get discovered and years of research to make them even more efficient. Some of them include selection sort, insertion sort, quick sort, radix sort etc.
            </p>
            <h2>Let’s look at some stats. Shall we?</h2>
            <div class="d-flex flex-column align-items-center pt-4 pb-4">
                <img src="images/article001/img2.png" alt="">
                <span class="text-muted">* time (on y-axis) v/s list size (on x-axis)</span>
            </div>
            <p>
                In this comparison, I’m picking 3 sorting methods. The infamous bubble sort (the first thing you’ll learn in the “How to become a programmer in 30 days?” book because it is probably the simplest sorting algorithm ever), insertion sort and quick sort.
            </p>
            <p>
                We can infer the below points from the above graph
            </p>
            <ul>
                <li>The x-axis represents the number of elements sorted and y-axis, the time it took to sort those elements.</li>
                <li>Bubble sort’s curve would make a dream come true graph for a company’s profit. Jokes apart, it performs so bad that it shouldn’t even be in the syllabus. I just put it here in the comparison to make you hate bubble sort even more.  </li>
                <li>Quick Sort amazed me. Didn’t you get amazed?! The graph speaks it all. Quick Sort seems to not want to let go off the axis. It is not a mistake; it is for real and it is a great quality to have for a sorting algorithm i.e., to not have a steep slope.</li>
            </ul>
            <p>
                Insertion sort was being widely used before this algorithm stole the show. Shown below are the rough empirical estimates on the running times of both insertion sort and quick sort on both a general-purpose home pc and a supercomputer.
            </p>
            <div class="d-flex flex-column align-items-center pt-4 pb-4">
                <img src="images/article001/img3.jpg" alt="">
                <span class="text-muted">* Assuming that a home PC executes 108 compares/sec and a supercomputer executes 1012 compares/sec.</span>
            </div>
            <h2>Why is it so efficient?</h2>
            <p>
                The algorithm is efficient mainly because it requires very small amounts of memory thus being cache friendly. In fact, the extra space needed to run this is constant. So, you won't be needing much extra space in memory and thus not letting the processor sit idle and wait for memory related stuff to take place or switch to a different process instead.
            </p>
            <p>
                Also, it takes on the approach of the divide and conquer, which is usually very effective in solving a problem. We all know how well the East India Company used this approach to break entire countries apart. don’t we?
            </p>
            <h2>So, technically…</h2>
            <p>
                <span class="badge badge-warning">Disclaimer</span> You may find some really disturbing, super-technical stuff in the next section. Reader's curiosity is mandatory.
            </p>
            <p>
                Below are the basic steps describing the approach of the quick sort algorithm.
            </p>
            <ol>
                <li>Randomly shuffle the array [Needed for performance guarantee as it performs better if the values are randomly ordered]</li>
                <li> Partition so that, for some j</li>
                <ul>
                    <li>Entry a[j] is in place</li>
                    <li>No larger entry to the left of j</li>
                    <li>No smaller entry to the right of j</li>
                </ul>
                <li> Sort each piece recursively.</li>
            </ol>
            <p>
                Now that you've crossed that section, here's an interesting fact. Quick sort performs the worst when the numbers are already sorted!
            </p>
            <h2>In the end, it does matter</h2>
            <p>
                As we look more and more into this subject matter, we tend to infer one important idea behind all these not good but great algorithms which is to reduce the overhead. Be it memory, running time, power consumption etc. As I quoted earlier, “Good algorithms are better than supercomputers”. Especially in this tremendously fast paced field of computer science. Still there are few problems that are left unsolved and it does matter to add your part of the spice to this delicious recipe called algorithm.
            </p>
        </div>
    </main>

    <div style="height: 8rem;"></div>
    <footer>
        <div class="text-center">
            Copyright &copy; LCC-JSSSTU 2020
        </div>
        <div class="d-flex justify-content-center">            
            <a href="https://github.com/LinuxCampusClubSJCE" target="_blank">
                <i class="fa fa-github"></i>
            </a>            
            <a href="https://www.facebook.com/LCCSJCE/" target="_blank">
                <i class="fa fa-facebook"></i>
            </a>            
            <a href="https://www.instagram.com/linuxcampusclub/" target="_blank">
                <i class="fa fa-instagram"></i>
            </a>
        </div>
    </footer>

    <script src="https://use.fontawesome.com/d956dfdb5f.js"></script>
</body>
</html>